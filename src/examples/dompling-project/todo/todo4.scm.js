input = "0epyt-riap,edon$,po-teg,epyt-lobmys,retnuoc-ot-dda,epyt-notelgnis,enifed,ppa,1h,$,esle,vne,dna,etouq,po-fi,x,nerdlihc&srtta,tel,nigeb,n,vid,niam,retnuoc,srtta,>1h<,ydob$,po-tsnoc,nerdlihc,gat-edon,epyt-erudecorp,elyts,>p<,dnoc,>nottub<,po-llac/pmuj,dlihc,ssalc@,po-tes,!tes-0dleif,edon-desrap,p,epyt-gnirts,fi,ro,elyts@,di@,kcilc:no@,]...[,adbmal,_,liat,!tes,nottub,>vid<,txet-tes,rotceles-yreuq,fer-gnirts,edon-ecalper,gnirts>-rebmun,vne-lave,*,sgra-on-tnenopmoc,!rac-tes,vne-elipmoc,>elyts<,nyd-edon-esrap,ton,elipmoc,poon-neg,gol.elosnoc,tneitouq,!tes-1dleif,!tes-tsil,nyd-lmth,raac,pmc-gnirts,ngissa-neg,xua-gnirtsbus,xua-pmc-gnirts,?tnemele-lmth,tsil>-gnirts,rdddac,di-yb-tnemele,pam,nerdlihc&srtta-tilps,2-tsil,?llun,llac-pmoc,2tsil,llac-neg,?ecnatsni,3tsil,xua-gnirts>-rebmun,fer-tsil,liat-tsil,dnetxe,gnirts>-tsil,htgnel,?regetni,+,nerdlihc-dda,dnib-pmoc,dneppa,1tsil,rtta-tes,?rpxe-enilni,tnenopmoc,tneve-dda,erudecorp-ekam,tnemele-etaerc,rddac,pukool,hcae-rof,?lauqe,?gnirts,fi-dliub,<,?bir,?=gnirts,nigeb-pmoc,0dleif,-,edon-lmth-ot,1dleif,htgnel-gnirts,esolc,2dleif,?lobmys,srtta-tes,gnirts>-lobmys,gnirtsbus,rddc,1gra,edon-esrap,2gra,lave,?vqe,edon-dneppa,pmoc,rdc,rac,rdac,di,?riap,snoc,,,,bir;.iSFiT&JHZDZNwSLv/!SFHGZ@iT:iT7iSE!T)8S%ZOiSEZ7iT8!SEZ&liSEy!SEuJEZIiT2YS$iT.!T&Z7iT1]N7#ZJ`^{!07#ZF^z]J8Ki&:DiS)ai&`k{]F8Ki&:DiS)ai&kkz!S):kw)k]*)_'Z*aC_B^~?^{!H)^8HZ&lbC`^)`~F_B_~?_|]290`^YHka_CaB`-Z2dCb>ai$B`^~?_|]E#`kn89^~i$#`kn89^~i$#`kn89^~i$#`kn89^~YBP^~Fw3S^~FkV^~YB^z]=#ZEa_l{]0#a_k#k_k~FiS)_{!@-b-:WfCdbw3k~?CaB`^|]$-W:h-w1k-Wf~FiS)fd>aaa^}(!P'i&^z]4'YP`^{]1'YP`^{].'Z1b`^|!D'Z.ca_wS1|!-#b`n9$f>i&>bwS*awS*`92>ea_`~O_C`-ci$-cYD>KdwS;>CAcwSIBAa-c>CAbwSI~FBAbwT#~?Ca_~FwS;^-ci$-cH^-cHZ.YD>KgwS0wS*wS*YPZ1`wS*wSJ~?KbAa~?Ca_~FwS0^-ci%-cH^-cHYDi$>KdwSO^~?KbAa~?Ca_~FwSO^9$fKdA`B_`BA`~FwSJ^8@cCa_~FwSI^#Z0ew:#d~Z3bYKi&:WiS)KeZ*>>fi$i$akZ(_nA`~FwS+^-:DgZ8ecDfYIdboAa_~FwS1^-Z=dYHlbAbYIa_~HFwT'_9$f>i&>bwS*awS*`92>ea_`~O_C`-ci$-cYD>KdwS;>CAcwSIBAa-c>CAbwSI~FBAbwT#~?Ca_~FwS;^-ci$-cH^-cHZ.YD>KgwS0wS*wS*YPZ1`wS*wSJ~?KbAa~?Ca_~FwS0^-ci%-cH^-cHYDi$>KdwSO^~?KbAa~?Ca_~FwSO^9$fKdA`B_`BA`~FwSJ^8@cCa_~FwSI^#Z0ew:#d~Z3bYKi&:WiS)KeZ*>>fi$i$akZ(_nA`~FwS+^-:DgZ8ecDfYIdboAa_~FwS1^-Z=dYHlbAbYIa_~H^~^FwS(^#cAan~FwSN^B_~?_#bYHk``m~O_|!SMo!SAn!T+m!S6l!S9k!G)i$8GC`^JX$B_~?_{]6)i&'Z6Ca_X$B_~?_{!K#l`^{]<9)a9<>fYS#bb`a_Ul`~YCa_}'!59<i&b`^|];)k)iT0~?_)l9;CbC`)l~YC`^)iT0~YC__B`B^~?_~?^{]>9;Z9`Z9^{!A/kZ>`^{!S#9,`V^{!;i<]9i?])#nZ(_^z!EZ/n]-)^9-_`~YCak>b^Z&UZMu``vR%ZCu^{]O9)Z-i&^9)>Z-i&U`kvP~YCk^z]'9GYB^zJZBki#!6i<!8Z/m]+)^9+Ul`C^~YC`k{]A9KaZ+`^|],+Z+`^{]#)_'Z#aC_B^~?^{]()k9&Z(C_l~?^z]3/i&^z]?8?V^z]88IS^z!I*S^z!48<S^z!*8?S^z]KiS5!,i<!+i?!'#k`^{!(Z/k!F)i$)i$)i$)i$8FVaV_~YFSaS_~YFPaP_~YB`)i$~FpP_~YB_)^~^F`^{]G/i$^z]/8:)i$/bP^~YB^zz!T(p!S2n!T*m!S>l!T-k]D:lkv4]::lkv5!.:lkv6!=:lkv7!J:lkv8!L:lkv9!S%:lkv:!O:lkv;]7:lkv<!S$:lkv=]@9H`^{]H9P_iT4{]P9,k^JZAZ6iT3Q)^9,lc~YFwSB^'i&Z4Z4fwSNwSH~YFwT,^zk^{!2)^JYG`Q)i$.I_a~?^.IGA_a~i$)i$.I_a~?^.IGA_a~YN^~?^.IG_a~O^.T_a~HYE_)i$.I_a~?^.IGA_a~i$)i$.I_a~?^.IGA_a~YN^~?^.IG_a~O^.T_a~H^~^Z'^zJNa^YJLUlRclaC_B^Z5C_MB^8=^~HYE_)^JYG`Q)i$.I_a~?^.IGA_a~i$)i$.I_a~?^.IGA_a~YN^~?^.IG_a~O^.T_a~HYE_)i$.I_a~?^.IGA_a~i$)i$.I_a~?^.IGA_a~YN^~?^.IG_a~O^.T_a~H^~^Z'^zJNa^YJLUlRclaC_B^Z5C_MB^8=^~H^~^Z'^z!N)i$)i$8AiT6MB^~OB^~?^z]57$`H^[$Q'_b7+_[,Z#>>i&bLRal_fM`K`A_B^~i$'_b7+_[,Z#>>i&bLRal_fM`K`A_B^~i$'_b7+_[,Z#>>i&bLRal_fM`K`A_B^~YAiT5LlkMB^~OB^~?^zi$i&z]IZLwS=!SCYMwT%!S:YMwS'!S<YMwS3!S&YMwSG]L8:)^JZ%`^[$YJMbi$zz!M8:)^JZ%a^JN`^[$YJMci${z]%)i$.`^~Z:_8G`Q9%G_az~?_.T`^~HYE`)i$.`^~Z:_8G`Q9%G_az~?_.T`^~H^~^Z'_{!7)i$87`bJYOb_b87`bJYLGbLRan_b~YAiT/Lnk^M`87`bJYOb_b87`bJYLGbLRan_b~YAiT/Lnk^`~YE`KaA`B_87`bJYOGb_b87`bJYLGbLRan_b~YAiT9Lnk^M`87`bJYOGb_b87`bJYLGbLRan_b~YAiT9Lnk^`~YE`CaCB`Z?_~?B_~?_{!T::ki&wSL!T7:k:k:k:k:k:k:k:ki&:k:k:k:ki&:nt:k:k:k:k:k:k:k:k:ki&vDvS,vS4vCvS2vS*vS0vS3vR8wT)wS-wS::k:k:k:ki&:k:ki&wSLwS,:nr:k:k:k:k:k:k:ki&vS9vS,vS;vS5vS<vS6vS*wS.wS<:k:ki&:nv/:k:k:k:k:k:k:k:k:k:k:k:ki&vDvS+vS3vS9vS6vS>vCvS6vS3vS3vS,vS/wSC:nv0:k:k:k:k:k:k:k:k:k:k:k:k:ki&vR0vS2vS*vS(vS3vS)vCvR/vS9vS6vS3vS6vS*wS/:no:k:k:k:ki&vS5vS0vS(vS4wS7wS&!T8:nr:k:k:k:k:k:k:ki&vS9vS,vS;vS5vS<vS6vS*!T2:nvT5:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vSDvCvCvCvCuv0vR0vS9vS,vS;vS5vS,vS*vCvR/vS:vS4vS,vS;vS0vPvS5vS.vS0vS3vS(vCvCvCvCvCvCuv0vR0vS9vS,vS;vS5vS,vS*vCvR/vS;vS5vS,vS;vS5vS6vS*vPvS@vS-vS0vS;vS:vS<vS1vCvCvCvCvCvCuv0vR0vS5vS4vS<vS3vS6vS*vCvR/vS5vS6vS0vS;vS*vS,vS9vS0vS+vPvS?vS,vS3vS-vCvCvCvCvCvCuv0vR0vS?vS,vS3vS-vCvR/vS@vS(vS3vS7vS:vS0vS+vCvCvCvCvCvCuv0vR0vEvS3vS(vS0vS9vR6vEvCvR/vS@vS3vS0vS4vS(vS-vPvS;vS5vS6vS-vCvCvCvCvCvCuv0vSBvCvS5vS0vS(vS4vR#!T.:no:k:k:k:ki&vS+vS(vS,vS/!T1:nn:k:k:ki&vS7vS7vS(!T0Ulk!T4:k:ki&:k:k:k:ki&:k:k:ki&:k:k:k:ki&:k:k:ki&:k:k:ki&:k:k:k:k:k:k:ki&wS4:k:k:ki&wS@:k:k:ki&:k:k:k:k:ki&:k:ki&:k:k:ki&:k:ki&wS8w2wS4w.:k:ki&wS8w(:k:ki&:k:k:ki&:k:ki&:k:k:ki&wSP:k:ki&wS8w*xNw2wS4w.:k:k:ki&:k:ki&wS8wN:k:ki&wS8w(wSO:k:ki&:k:k:ki&:k:ki&wS8w2wS4w.:k:ki&wS8w8:k:ki&:k:k:ki&:k:ki&wS8w=wS4w.:k:k:ki&:k:ki&wS8wE:k:ki&wS8x'wS0wS;:ki&wS8wS+wG:k:ki&wS@xD:k:k:ki&wSDwS4w7:k:ki&wS4xD:ki&:k:ki&:k:ki&:k:k:k:ki&:k:k:ki&l:k:ki&wS?w;w>lwS?w5wJwS4wSJ:ki&:k:ki&:k:ki&wSKw,wS@wSJ:ki&:k:ki&:k:ki&wSKw+wSDwSJ:k:ki&wS?xD:ki&:k:ki&:k:ki&:k:ki&wSHw,x5wSKwSJ:ki&:k:ki&:k:ki&:k:ki&wSHw+w6wS?wSJ:k:ki&wSHw=:k:k:ki&:k:ki&wSHwE:k:ki&wSHx'wS0wS1wT$!T3:k:k:ki&wSBwT,wSJ!T6:np:k:k:k:k:ki&vS$vR#vR#vR#vRP!T5:nl:ki&vR5!T/:nn:k:k:ki&vR/vS5vS6!T9:nn:k:k:ki&vR/vS5vS6!):lkl!3:lkm!1:lkn!::lko!B:lkp!?:lkq!<:lkr!9:lks!S5:lkt]B:lku!/:lkv.!C:lkv/]&:lkv0!>:lkv1]M:lkv2]C:lkv3y"; // RVM code of the program

debug = false; //debug


lengthAttr = "length";

nodejs = ((function () { return this !== this.window; })()); //node
if (nodejs) { // in nodejs? //node

  // Implement putchar/getchar to the terminal //node

  node_fs = require("fs"); //node

  putchar = (c) => { //node
    let buffer = Buffer.alloc(1); //node
    buffer[0] = c; //node
    node_fs.writeSync(1, buffer, 0, 1); //node
    return c; //node
  }; //node

  getchar_sync = () => { //node
    let buffer = Buffer.alloc(1); //node
    if (node_fs.readSync(0, buffer, 0, 1)) //node
      return buffer[0]; //node
    return -1; //node
  }; //node

  getchar = () => { //node
    push(pos<input[lengthAttr] ? get_byte() : getchar_sync()); //node
    return true; // indicate that no further waiting is necessary //node
  }; //node

  sym2str = (s) => chars2str(s[1][0]); //node //debug
  chars2str = (s) => (s===NIL) ? "" : (String.fromCharCode(s[0])+chars2str(s[1])); //node //debug
  show_opnd = (o) => is_rib(o) ? "sym " + sym2str(o) : "int " + o; //node //debug
  show_stack = () => { //node //debug
    let s = stack; //node //debug
    let r = []; //node //debug
    while (!s[2]) { r[r[lengthAttr]]=s[0]; s=s[1]; } //node //debug
    console.log(require("util").inspect(r, {showHidden: false, depth: 2})); //node //debug
  } //node //debug

} else { // in web browser //node

  // Implement a simple console as a textarea in the web page

  domdoc = document;
  selstart = 0;
  addEventListenerAttr = "addEventListener";
  selectionStartAttr = "selectionStart";

  domdoc[addEventListenerAttr]("DOMContentLoaded", () => {
    run();
  });

  putchar = (c) => (selstart=txtarea[selectionStartAttr]=(txtarea.value += String.fromCharCode(c))[lengthAttr], c);

  getchar = () => pos<input[lengthAttr] && push(get_byte());
  show_stack = () => {console.log(stack)};
  sym2str = (s) => chars2str(s[1][0]); //node //debug
  chars2str = (s) => (s===NIL) ? "" : (String.fromCharCode(s[0])+chars2str(s[1])); //node //debug
  show_opnd = (o) => is_rib(o) ? "sym " + sym2str(o) : "int " + o; //node //debug
} //node

// VM

// build the symbol table

pos = 0;
get_byte = () => input[pos++].charCodeAt(0);
get_code = () => { let x = get_byte()-35; return x<0 ? 57 : x; };
get_int = (n) => { let x = get_code(); n *= 46; return x<46 ? n+x : get_int(n+x-46); };

pop = () => { let x = stack[0]; stack = stack[1]; return x; };

FALSE = [0,0,5]; TRUE = [0,0,5]; NIL = [0,0,5];

symtbl = NIL;
n = get_int(0);
while (n-- > 0) symtbl=[[0,[NIL,0,3],2],symtbl,0]; // symbols with empty names

accum = NIL;
n = 0;
while (1) {
  c = get_byte();
  if (c == 44) { symtbl=[[0,[accum,n,3],2],symtbl,0]; accum = NIL; n = 0; continue; }
  if (c == 59) break;
  accum = [c,accum,0];
  n++;
}

symtbl = [[0,[accum,n,3],2],symtbl,0];

symbol_ref = (n) => list_tail(symtbl,n)[0];
list_tail = (x,i) => i ? list_tail(x[1],i-1) : x;

// decode the instruction graph

stack = 0;

while (1) {
  x = get_code();
  n = x;
  d = 0;
  op = -1;
  while ((d=[20,30,0,10,11,4][++op])+2<n) n -= d+3;
  if (x>90)
    n = pop();
  else {
    if (!op) stack = [0,stack,0];
    n = n>=d ? (n==d ? get_int(0) : symbol_ref(get_int(n-d-1))) : op<3 ? symbol_ref(n) : n;
    if (4<op) {
      n = [[n,0,pop()],0,1];
      if (!stack) break;
      op=4;
    }
  }
  stack[0] = [op?op-1:0,n,stack[0]];
}

set_global = (x) => { symtbl[0][0] = x; symtbl = symtbl[1]; };

set_global([0,symtbl,1]); // primitive 0
set_global(FALSE);
set_global(TRUE);
set_global(NIL);

// RVM core

pc = n[0][2];
stack = [0,0,[5,0,0]]; // primordial continuation (executes halt instr.)

push = (x) => ((stack = [x,stack,0]), true);
bool_to_rib = (x) => x ? TRUE : FALSE;
// )@@
str_to_rib = (s) => {
    let l = s.length
    let i = l
    let a = NIL
    while (i) a=[s.charCodeAt(--i),a,0];
    return [a,l,3]
}
// )@@

find_sym = (name, symtbl) => {
  lst = rib_to_list(symtbl)
  return list_tail(symtbl, lst.indexOf(name))[0]

}
// )@@

function_to_rib = (f) => {
  let host_call = find_sym('host-call', symtbl)
  let id = find_sym('id', symtbl)
  let arg2 = find_sym('arg2', symtbl)
  let rib = [[0, 0, 1], [NIL, 0, 3], 2]
  if (host_call == -1 || id == -1){
    console.log("ERROR : you must define host-call as a primitive to convert a function to a rib")
    return 
  }

  let code = [3, foreign(f),  // push(foreign(f))
              [2, 1, // inverse arguments
               [0, host_call,  // call host_call primitive
                [0, arg2, // discard argument on stack
                 [0, id, 0]]]]] // return 
  let i = f.length // number of args
  while(i--){
    code = [3, 0,  // push 0
             [0, rib, // call rib
              code]]
  }
  code = [f.length, 0,     // number of params
          [3, NIL, code]] // push nil

  let env = 0 // no environment
  return [code, env, 1] // return the procedure
}
// )@@

any_to_rib = (v) => {
  return ({"number":(x)=>x,"boolean":bool_to_rib,"string":str_to_rib,"object":(x) => !Array.isArray(x) ? foreign(x) : list_to_rib(x), 'function':function_to_rib, 'undefined':()=>NIL}[typeof v](v))
}
// )@@

list_to_rib = (l,i=0) => (i<l.length?[any_to_rib(l[i]),list_to_rib(l,i+1),0]:NIL)
// )@@

rib_to_str = (r) => {
    let f = (c) => (c===NIL?"":String.fromCharCode(c[0])+f(c[1]))
    return f(r[0])
}
// )@@

rib_to_bool = (r) => {
  if (r === NIL){
    return []
  }
  if (r === FALSE){
    return false
  }
  if (r === TRUE){
    return true
  }
  console.error("Cannot convert ", r, " to bool");
}
// )@@

rib_to_list = (r) => {
  let elems = r[2] === 0 ? r : r[0];
  let lst = [];
  let f = (c) => {
    if (c !== NIL){
      lst.push(rib_to_any(c[0]))
      f(c[1])
    }
  }
  f(elems)
  return lst
}
// )@@

rib_to_function = (r) => {
  let func_stack = []
  let func = (...args) => {
    func_stack.push(pc)
    push(r)
    for(let a in args){
      push(any_to_rib(a))
    }
    pc = [0,args.length,[5, 0, 0]] // call function and then halt
    run()
    pc = func_stack.pop()
    return_value = pop()
    return rib_to_any(return_value)
  }
  return func
}
// )@@


rib_to_symbol = (r) => {
  return rib_to_str(r[1])
}
// )@@


rib_to_any = (r) => {
  if (r === undefined) return r;
  if (typeof r === "number") return r;
  let tag = r[2]
  return [rib_to_list, rib_to_function, rib_to_symbol, rib_to_str, rib_to_list, rib_to_bool, (x) => x[1]][tag](r);
}
 // )@@


foreign = (r) => [0, r, 6] // 6 is to tag a foreign object
// )@@

// f is a foreign object representing a function
host_call = () =>{
  args = pop();
  f = pop()[1];
  let r = f(...rib_to_list(args));
  return push(any_to_rib(r))
} 
// )@@

is_rib = (x) => x[lengthAttr];

get_opnd = (o) => is_rib(o) ? o : list_tail(stack,o);
get_cont = () => { let s = stack; while (!s[2]) s = s[1]; return s; };

prim1 = (f) => () => push(f(pop()));
prim2 = (f) => () => push(f(pop(),pop()));
prim3 = (f) => () => push(f(pop(),pop(),pop()));

primitives = [
  prim3((z, y, x) => [x, y, z]),                    //  @@(primitive (rib a b c))@@
  prim1((x) => x),                                  //  @@(primitive (id x))@@
  () => (pop(), true),                              //  @@(primitive (arg1 x y))@@
  () => { let y = pop(); pop(); return push(y); },  //  @@(primitive (arg2 x y))@@
  () => push([pop()[0],stack,1]),                   //  @@(primitive (close rib))@@
  prim1((x) => bool_to_rib(is_rib(x))),             //  @@(primitive (rib? rib) (use bool_to_rib))@@
  prim1((x) => x[0]),                               //  @@(primitive (field0 rib))@@
  prim1((x) => x[1]),                               //  @@(primitive (field1 rib))@@
  prim1((x) => x[2]),                               //  @@(primitive (field2 rib))@@
  prim2((y, x) => x[0]=y),                          //  @@(primitive (field0-set! rib))@@
  prim2((y, x) => x[1]=y),                          //  @@(primitive (field1-set! rib))@@
  prim2((y, x) => bool_to_rib(x===y)),              //  @@(primitive (eqv? x y) (use bool_to_rib))@@
  prim2((y, x) => bool_to_rib(x<y)),                //  @@(primitive (< x y) (use bool_to_rib))@@
  prim2((y, x) => x+y),                             //  @@(primitive (+ x y))@@
  prim2((y, x) => x-y),                             //  @@(primitive (- x y))@@
  prim2((y, x) => x*y),                             //  @@(primitive (* x y))@@
  prim2((y, x) => x/y|0),                           //  @@(primitive (quotient x y))@@
() => push(console.log(rib_to_any(pop()))),prim1((e) => bool_to_rib(Array.isArray(e) && e[1] instanceof HTMLElement)),prim2((element, parent) => parent[1].append(rib_to_any(element))),() => push(foreign(document.createTextNode(rib_to_any(pop())))),() => push(foreign(document.createElement(rib_to_str(pop())))),prim3((value, name, e) => (e[1].addEventListener(rib_to_str(name), eval(rib_to_any(value))))),prim2((value, e) => any_to_rib((e[1].innerText = rib_to_any(value)))),prim3((value, name, e) => any_to_rib((e[1].setAttribute(rib_to_str(name), rib_to_any(value))))),() => push(foreign(document.getElementById(rib_to_str(pop())))),() => push(foreign(document.querySelector(rib_to_str(pop())))),];

run = () => {
  while (1) {
    let o = pc[1];
    switch (pc[0]) {
    case 5: // halt
        return;
    case 0: // jump/call
        if (debug) { console.log((pc[2]===0 ? "--- jump " : "--- call ") + show_opnd(o)); show_stack(); } //debug
        o = get_opnd(o)[0];
        let c = o[0];
        if (is_rib(c)) {
            let c2 = [0,o,0];
            let s2 = c2;
            let nargs = c[0];
            if (nargs < 0) {
              while (nargs++) s2 = [pop(),s2,0];
            } else {
              while (nargs--) s2 = [pop(),s2,0];
            }
            if (pc[2]===0) {
                // jump
                let k = get_cont();
                c2[0] = k[0];
                c2[2] = k[2];
            } else {
                // call
                c2[0] = stack;
                c2[2] = pc[2];
            }
            stack = s2;
        } else {
            if (!primitives[c]()) return;
            if (pc[2]===0) {
                // jump
                c = get_cont();
                stack[1] = c[0];
            } else {
                // call
                c = pc;
            }
        }
        pc = c;
        break;
    case 1: // set
        if (debug) { console.log("--- set " + show_opnd(o)); show_stack(); } //debug
        get_opnd(o)[0] = pop();
        break;
    case 2: // get
        if (debug) { console.log("--- get " + show_opnd(o)); show_stack(); } //debug
        push(get_opnd(o)[0]);
        break;
    case 3: // const
        if (debug) { console.log("--- const " + o); show_stack(); } //debug
        push(o);
        break;
    case 4: // if
        if (debug) { console.log("--- if"); show_stack(); } //debug
        if (pop() !== FALSE) { pc = pc[1]; continue; }
        break;
    }
      pc = pc[2];
  }
};

if (nodejs) run(); //node
