input = "4?>rahc,dneppa-gnirts,?gat-lmth,niam,?naeloob,>2h<,elyts@,di@,dna,cc/llac,dnuor,rtta-teg,>vid<,epyt-erudecorp,etouq,>p<,naps,raaaac,>lo<,radddc,6h,epyt-gnirts,e-lave,esle,raaddc,>,!rdc-tes,rotaremun,>naps<,fer-rav-labolg,5h,>4h<,oludom,rotanimoned,?tsil,>il<,po-llac/pmuj,po-fi,rddddc,4h,qmem,edoc-erudecorp,!tes,ro,rdadac,>rb<,elyts,3h,lbtmys,po-tsnoc,p,?orez,xam,epyt-rotcev,qssa,retnuoc-teg,2h,erp,?evitisop,vid,ytpme,roolf,elyts-tes,?=>gnirts,rdaddc,raddac,1h,adbmal,gniliec,>6h<,ppa,fi,rdaadc,>van<,tnemucod-teg,mcl,epyt-lobmys,nottub,reffub,!tes-gnirts,?evitagen,raaadc,>tupni<,>lu<,kcilc:no@,]...[,po-teg,lebal,enifed,liat,rahc>-regetni,epyt-riap,!tes-rotcev,rddadc,>1h<,rddaac,nyd-lmth,radaac,nigeb,retnuoc-ot-dda,van,?=rahc,rotcev-ekam,_,rdaaac,etacnurt,>lebal<,?=<rahc,htgnel-rotcev,>3h<,=<,lo,raadac,epyt-notelgnis,il,?=<gnirts,tel,rahc-etirw,?<rahc,fer-rotcev,=>,retnuoc,!llif-gnirts,gol.elosnoc,nim,gnirts-ekam,>nottub<,>erp<,!tes-rav-labolg,?=>rahc,mrof,regetni>-rahc,po-tes,!llif-rotcev,ssalc@,foe,ypoc-gnirts,>mrof<,radadc,dnoc,lu,vne-erudecorp,>5h<,tupni,=,cossa,!tes-2dleif,?qe,tsil>-rotcev,fer-gnirts,lobmys>-gnirts,txet-tes,dcg,vne-w-elipmoc,>elyts<,vssa,tpxe,+,!rac-tes,*,redniamer,llac-dna-dniwnu,rahcteg,lobmys-denretninu>-gnirts,rotceles-yreuq,lmth,tixe,?<gnirts,pam,elipmoc,?>gnirts,?ddo,rebmem,vmem,?neve,poon-neg,rebmun>-gnirts,esrever,nyd-edon-esrap,sgra-on-tnenopmoc,enilwen,xua-esrever,radac,!tes-tsil,tsil-etirw,lper,raadc,rdadc,tnemmoc-piks,?tsil-rahc,xua-lobmys>-gnirts,rdaac,xua-gnirtsbus,radc,xua-tsil-ekam,ngissa-neg,xua-rebmun>-gnirts,raaac,rdddac,raddc,?tnemele-lmth,di-yb-tnemele,rdddc,tsil-daer,2xua-rebmun>-gnirts,gnirts>-rebmun,xua-rahc-daer,!tes-1dleif,fer-tsil,xua-?tsil,raac,llac-neg,pmc-gnirts,liat-tsil,rorre,dnetxe,1tsil,?tcejbo-foe,xua-dcg,rotcev>-tsil,3tsil,2tsil,llac-pmoc,tneitouq%,xua-pmc-gnirts,xua-gnirts>-rebmun,lobmys-daer,tneve-dda,?erudecorp,erudecorp-ekam,nerdlihc-dda,ecapsetihw-non-rahc-keep,rtta-tes,dnib-pmoc,sba,nerdlihc&srtta-tilps,tneitouq,tsil-ekam,yalpsid,etirw,htgnel,pukool,!tes-0dleif,2rahctup,?ecnatsni,daer,?bir,+%,srahc-daer,fi-dliub,dneppa,?rotcev,?lauqe,rddac,rahc-keep,-,?llun,nigeb-pmoc,hcae-rof,tnemele-etaerc,?rpxe-enilni,gnirts>-tsil,?=gnirts,ton,2dleif,tsil>-gnirts,srahc-etirw,<,0dleif,htgnel-gnirts,srtta-tes,esolc,edon-lmth-ot,gnirts>-lobmys,?lobmys,1dleif,tnenopmoc,xeh-daer,gnirtsbus,rddc,?gnirts,?regetni,rahctup,*%,<%,lave,pmoc,rahc-daer,2gra,rorre-epyt,edon-esrap,-%,rdac,edon-dneppa,snoc,rac,?riap,rdc,?vqe,1gra,di,,,,bir;.iW<iV'!W<JYT$iWPiTP!U88T2YS*iTPYS.iWD!TPYT,liTPy!V6'iTPy!TPu?EYT/iWBYT%iWN!V'YS.iWH!T(i$]O8T(YD8T#k?YS>?YSC?Z6a?Z7iWM?Z7`y{!29Oi&iWLy!S>8S>?YSC?Z6M^'i$~ZL^Z0?Z2vCvR3y!W)7#YT0`^{!67#YSN^z!T09@`:LiUBai&kk{!SN9@i&:LiUBai&kkz!UB:kw'k]N'_-ZNaA_C^~B^{]4'^94Z.lbA`^'`~@_C_~B_|]G8S$`^Z4ka_AaC`5ZGdAbDai$C`^~B_|!SH#`kn8K^~i$#`kn8K^~i$#`kn8K^~i$#`kn8K^~Z/YK^~@w(W^~@kYG^~Z/^z!S4#YSHa_l{!S$#a_k#k_k~@iUB_{]$5b5:Z$fAdbw(k~BAaC`^|]<5Z$:h-w3k5Z$f~@iUBfdDaaa^}(]M-i&^z]H-ZM`^{]I-ZHb`^|],-ZIca_wV&|!5#b`n9<fDi&DbwU4awU4`9GDea_`~YA_A`5ci$5cZ,DSdwT>DAFcwU9CFa5cDAFbwU9~@CFbwW(~BAa_~@wT>^5ci$5cJ^5cJZIZ,DSgwVBwU4wU4ZMZH`wU4wU'~BSbFa~BAa_~@wVB^5ci%5cJ^5cJZ,i$DSdwW7^~BSbFa~BAa_~@wW7^9<fSdF`C_`CF`~@wU'^9$cAa_~@wU9^#YS$ewD#d~Z%bZ@i&:Z$iUBSeZNDDfi$i$akZ5_nF`~@wV*^5:LgYS1ecLfZ(dboFa_~@wV&^5YS4dZ4lbFbZ(a_~J@wUC_9<fDi&DbwU4awU4`9GDea_`~YA_A`5ci$5cZ,DSdwT>DAFcwU9CFa5cDAFbwU9~@CFbwW(~BAa_~@wT>^5ci$5cJ^5cJZIZ,DSgwVBwU4wU4ZMZH`wU4wU'~BSbFa~BAa_~@wVB^5ci%5cJ^5cJZ,i$DSdwW7^~BSbFa~BAa_~@wW7^9<fSdF`C_`CF`~@wU'^9$cAa_~@wU9^#YS$ewD#d~Z%bZ@i&:Z$iUBSeZNDDfi$i$akZ5_nF`~@wV*^5:LgYS1ecLfZ(dboFa_~@wV&^5YS4dZ4lbFbZ(a_~J^~^@wVC^#cFan~@wW1^C_~B_#bZ4k``m~YA_|!VHo!V<n!UEm!TEl!VIk]289_?P^{!SC89uy!U&289^~Q^z!I'i$8IaA_?P^8IaA_?P^?PvS#~J@vS#_8IaA_?P^8IaA_?P^?PvS#~J^~^@vE^8IaA_?PvS;?PvS#~@t^8IaA_?PvS9?PvS#~@v0^8IaA_?PvS5?PvS#~@u^8IaA_?P^~YL`C^~B^{!S?'i$'i$8S?A^?Z6C^~B^?PvC~B^z]797YS*^92vS7vF~ZA^96YT5^?PvF~Z*^8Ii$YJ^~R^97YB^~YA^89vL?YS?A^?Z6C^?PvK~B^92vLvK~Z%^92vS;vF~@i%^92vS-vF~YL^z]697^89vE?YIi%YJ^?PvE~R^z!S;8S;9>~@u^'^~Nk^Ky]>9>?K'^8S;~@vR0^~N_vC'iWC~ZL^Z'y]-9-D`^9-Da^9-Dat~@vS;^9-Dav0~@vS9^9-Dau~@vS5^K~@vS#^8SF_~@vE^'i&~ZL^Kz]C-ZC^?K'i&~JJNvD`-ZC^?K'i&~JJ^~^@vL_-ZC^?K'i&~J^~^@vK^Z'y!S,-YS,^Z0'i&?K~@vL^Z>y!>'_8>GGvRL_O`v3?K~i$'_8>GGvRL_O`v3?K~NvS.^~N_vS'8>GGvR,_O`v3?K~i$'_8>GGvRL_O`v3?K~i$'_8>GGvRL_O`v3?K~NvS.^~N_vS'8>GGvR,_O`v3?K~NvR<^~N_vR58>GGvR%_O`v3?K~i$'_8>GGvRL_O`v3?K~i$'_8>GGvRL_O`v3?K~NvS.^~N_vS'8>GGvR,_O`v3?K~i$'_8>GGvRL_O`v3?K~i$'_8>GGvRL_O`v3?K~NvS.^~N_vS'8>GGvR,_O`v3?K~NvR<^~N_vR58>GGvR%_O`v3?K~NvR/^~N_vR$Z'z]08T3`'^~^^YSG^YNDZC^?K8NZ-i&?K~@vE^-Di&Z0wW1?K~@vJ^9JZ00Ukk8>k?K~@vP^Z'?K~J@vRM_9JZ00Ukk8>k?K~@vP^Z'?K~J^~^@vS?^'i%?K~@vS;^'i$?K~@vS-^Z'?K~@vF^8S,?K~@vK^'^~Nk^Z>y]''^!UM^Ky!S)'^!UMiWA'^~@iWC^!UM^z!48S)^8S)YT'~@iWA^'^~@iWC^iUMy!UMiWA!V1iWA]L)iWC^z!TBiWC!W627%YD'_?YT7YKc^?Z3YGc^WWYDi$zWWYDi$~ZA^z]#2'i$9#A`^?X$C_~B_~ZA^{!SO2'i&-YSOAa_X$C_~B_~ZA^{!T<i@!VDiG]@#l`^{]AZ1l!TD293Z8aW_^~Z*^{!U59JZ8k^z!U?28S@b`YG^~Z*^|!U$28S'`YG^~Z*^{!U/28@^~Z*^z!T528G^~Z*^z]J#oZ5_^z]*Z1o!TO293Z8aW_^~i$293Z8aW_^~Q_~R^{!TA8NZ+i&YJ^z!W>8NZ+YJ`YJ^{!S78Na8S7DfYT4bb`a_Gl`~YHa_}'!=8S7i&b`^|]E'k'iWC~B_'l9EAbA`'l~N`^'iWC~N__C`C^~B_~B^{!S#29EYJ`YJ^~i$29EYJ`YJ^~R_~R^{!V.8LYSP`^{!U(8LYSM`^{!SM87YS#a_k{!SP87kYS#`^{!M)kYS#`^{!TL8NZ8vC^z!UL28S@b`YG^~R^|!T428S'`YG^~R^{!F28@^~R^z!J28G^~R^z!S:'i%'i$8S:A_~Q^C^~B^z!N2#nZ5_^~YS:^z!;Z1n!UAi'!TFi'!THiU#!U0iU-!W?iW&!U%iH!U6i)!S+'_'i$'i$8S+GGvR%`ObuA_~NvR/^~N_vR$C^~B^{!S38S+k^'i$~Z%^z!SG2'i$0_k~^YS3^8S3A^~@vPC^'i$~Z%^YJ^~R^z]D'^9D_`~NakDb^Z.GOu``vR%Z9u^{!S*8NZDi&^8NDZDi&G`kvP~YHk^z!T-'^88__~YSL`YT-Z9m`YT*_^'l~@k_{!W5i'!U2i'!V)i'!V0i'!VL'lz!W$i'!UP88_ZFYT1``_Z;`Z;^'k~@k_{]K9K_YT)__'_~@k^{!T19K`^9K__~N__Z;`Z;^{!VM9.b^'^~@NkbNk`'k~@k^GO`a_Z9`^{!T)0OZ9b``^{];'^0_k~YHk^z!TM'_'^~YH`^{!V9'^'_~YH`^{!SL8LYSI^z!SI)OZ9m`m^z!UK8Hk^z!V38H_kz!V:)k^z!U#8LYH`^{!U-8LYH__{!W&8H__{!H287`^~i$287`^~Q_~Q^{!T92)`^~i$2)`^~Q_~Q^{]929F`^9O_iWO~@k_~i$29F`^9O_iWO~@k_~Q_~Q^{!T*288`^~i$288`^~Q_~Q^{]&20`^~i$20`^~Q_~Q^{!T,29.`^~i$29.`^~Q_~Q^{!:8LZ/^z?YS(ki#!V=Wi#!S9'^!V=DiV=^YT&^8S9Wa_'^~Z)`W^YG_~B_{!T328S9iV=^~R^z!TIj3!VPiG!B28@^~YA^z!T&#m_i$z!AZ1m!S5'`8S5Dca`Gl^~YH_k|]88S5i&`^{!T8'i$8T8Aa_'^~Z)C__C_~B_{!V7iT.!T.'i$8T.Aa_'^~@C__C_~B_{!SK'i$8SKA`^'_~Z)C`^~B_{!VEiSJ!SJ'i$8SJA`^'_~@C`^~B_{]P'^9PGl`A^~YH`k{!S@8T+aZP`^|!S',ZP`^{!SB'_8SBDaC_A^~B^{!SF8SBi&^z]+'_-Z+aA_C^~B^{]5'k9.Z5A_l~B^z!S&9%^9%^8S&AaA^~B^'i$~YT6a^A^~B^{!VK8S&_^z]%)i&^z!VG8S-A^z!W,8S-C^z!V-8S0A^z!W'8S0C^z!U>8S<A^z!T?8S<C^z!V%8S=A^z!UJ8S=C^z!V,9(C^z!VA8SAA^z!U+8SAC^z!U<8S8A^z!U:8S8C^z!U38S2A^z!W.8S2C^z!S-8<A^z!S08<C^z!S<8S6A^z!S=8S6C^z!SA/C^z!S88S%A^z!S28S%C^z!S6*C^z!S%,C^z!S19(A^z](/A^z!<*A^z!/,A^z!W%28S(`^~B^{!T+293`^~B^{!*28@^~B^z!,28G^~B^z!-#k`^{!+Z1k])'i$'i$'i$'i$9)YGaYG_~Z)WaW_~Z)YKaYK_~Z/`'i$~@pYK_~Z/_'^~^@`^{!T6i)!W;8L_'^~^@i%^z!L)i$^z]18D'i$)bYK^~Z/^zz!U*p!V8o!W*n!UOm!W2l!U@k]Fj9!8iT*!0j&].iT,!7iH!V#:lkv8!TN:lkv9!S/:lkv:!.:lkv;!C:lkv<!P:lkv=]B:lkv>!V/:lkv?!T2:lkv@]=:lkvA!W4:lkvB!S.:lkvC!T%:lkvD!U;8SE^z!SE'^?Z#`YD'i$.H_a~B^.HMF_a~i$'i$.H_a~B^.HMF_a~YO^~B^.HM_a~YA^.YC_a~JR_'i$.H_a~B^.HMF_a~i$'i$.H_a~B^.HMF_a~YO^~B^.HM_a~YA^.YC_a~J^~^Q^z?YEa^YPTZ&lYFclaA_C^Z:A_YBC^8C^~JR_'^?Z#`YD'i$.H_a~B^.HMF_a~i$'i$.H_a~B^.HMF_a~YO^~B^.HM_a~YA^.YC_a~JR_'i$.H_a~B^.HMF_a~i$'i$.H_a~B^.HMF_a~YO^~B^.HM_a~YA^.YC_a~J^~^Q^z?YEa^YPTZ&lYFclaA_C^Z:A_YBC^8C^~J^~^Q^z!T$1^z!1'^?Z#`YD'i$.H_a~B^.HMF_a~i$'i$.H_a~B^.HMF_a~YO^~B^.HM_a~YA^.YC_a~JR_'i$.H_a~B^.HMF_a~i$'i$.H_a~B^.HMF_a~YO^~B^.HM_a~YA^.YC_a~J^~^Q^z?YEa^YPTZ&lYFclaA_C^Z:A_YBC^8C^~JR_'^?Z#`YD'i$.H_a~B^.HMF_a~i$'i$.H_a~B^.HMF_a~YO^~B^.HM_a~YA^.YC_a~JR_'i$.H_a~B^.HMF_a~i$'i$.H_a~B^.HMF_a~YO^~B^.HM_a~YA^.YC_a~J^~^Q^z?YEa^YPTZ&lYFclaA_C^Z:A_YBC^8C^~J^~^Q^z!O'i$'i$8MiW@YBC^~YAC^~B^z!W='i$'i$8MiWJTYF`Z&lYF_^~YMiWKTlk^YB^~YA^z]:7$`J^[$YD-_b7+_[,Z+DDi&bTYFal_fYB`S`F_C^~i$-_b7+_[,Z+DDi&bTYFal_fYB`S`F_C^~i$-_b7+_[,Z+DDi&bTYFal_fYB`S`F_C^~YMiWGTlkYBC^~YAC^~B^zi$[$i&i$z!T/YSDwV?!VJVwU)!UHVwT=!W-VwU,!U1VwUD!T@VwTG!V$VwU7!V(VwW+!T;VwVO!VNVwVF!U.VwV>!W:VwV5!U=VwV+!TKVwUN!UIVwT:!V@8PiWIy!TJVwV4!W0VwV;!W#VwW/!W3VwV2!SD8D'^?Z?`^[$YPYBbi$zz!?8D'^?Z?a^?YE`^[$YPYBci${z]?'i$.`^~YS/_9#`YD9?M_az~B_.YC`^~JR`'i$.`^~YS/_9#`YD9?M_az~B_.YC`^~J^~^Q_{!E'i$8E`b?Z=b_b8E`b?ZBMbTYFan_b~YMiWETnk^YB`8E`b?Z=b_b8E`b?ZBMbTYFan_b~YMiWETnk^`~R`SaF`C_8E`b?Z=Mb_b8E`b?ZBMbTYFan_b~YMiWFTnk^YB`8E`b?Z=Mb_b8E`b?ZBMbTYFan_b~YMiWFTnk^`~R`AaAC`YS%_~BC_~B_{!WP:k:k:k:k:k:k:k:ki&:k:k:k:ki&:nt:k:k:k:k:k:k:k:k:ki&vDvS,vS4vCvS2vS*vS0vS3vR8wU8wUGwTK:k:k:k:ki&:k:ki&wTPwUF:nr:k:k:k:k:k:k:ki&vS9vS,vS;vS5vS<vS6vS*wW8wW0:k:ki&:nv/:k:k:k:k:k:k:k:k:k:k:k:ki&vDvS+vS3vS9vS6vS>vCvS6vS3vS3vS,vS/wU=:nv0:k:k:k:k:k:k:k:k:k:k:k:k:ki&vR0vS2vS*vS(vS3vS)vCvR/vS9vS6vS3vS6vS*wW9:no:k:k:k:ki&vS5vS0vS(vS4wTCwW3!WD:nr:k:k:k:k:k:k:ki&vS9vS,vS;vS5vS<vS6vS*!WB:nvT5:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vSDvCvCvCvCuv0vR0vS9vS,vS;vS5vS,vS*vCvR/vS:vS4vS,vS;vS0vPvS5vS.vS0vS3vS(vCvCvCvCvCvCuv0vR0vS9vS,vS;vS5vS,vS*vCvR/vS;vS5vS,vS;vS5vS6vS*vPvS@vS-vS0vS;vS:vS<vS1vCvCvCvCvCvCuv0vR0vS5vS4vS<vS3vS6vS*vCvR/vS5vS6vS0vS;vS*vS,vS9vS0vS+vPvS?vS,vS3vS-vCvCvCvCvCvCuv0vR0vS?vS,vS3vS-vCvR/vS@vS(vS3vS7vS:vS0vS+vCvCvCvCvCvCuv0vR0vEvS3vS(vS0vS9vR6vEvCvR/vS@vS3vS0vS4vS(vS-vPvS;vS5vS6vS-vCvCvCvCvCvCuv0vSBvCvS5vS0vS(vS4vR#!WN:no:k:k:k:ki&vS+vS(vS,vS/!WH:nn:k:k:ki&vS7vS7vS(!WM:nl:ki&vC!WL:nv1:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vS9vS6vS9vS9vS,vCvS,vS7vS@vS;vCvMvMvM!WAZ&mk!WCZ&lk!WO:nv2:k:k:k:k:k:k:k:k:k:k:k:k:k:k:ki&vR%vCvS@vS)vCvS,vS+vS0vS=vS0vS+vCvMvMvM!W@:np:k:k:k:k:ki&vS$vR#vR#vR#vRP!WJ:nl:ki&vR3!WK:nl:ki&vR1!WG:nl:ki&vR5!WI:nm:k:ki&vS9vS)!WE:nn:k:k:ki&vR/vS5vS6!WF:nn:k:k:ki&vR/vS5vS6!':lkl!(:lkm!3:lkn!D:lko]/:lkp!G:lkq!@:lkr!K:lks]3:lkt!S(:lku!T7:lkv.!):lkv/!H:lkv0!T,:lkv1]&:lkv2!T*:lkv3]9:lkv4!T':lkv5!9:lkv6!T#:lkv7y"; // RVM code of the program

debug = false; //debug


lengthAttr = "length";

nodejs = ((function () { return this !== this.window; })()); //node
if (nodejs) { // in nodejs? //node

  // Implement putchar/getchar to the terminal //node

  node_fs = require("fs"); //node

  putchar = (c) => { //node
    let buffer = Buffer.alloc(1); //node
    buffer[0] = c; //node
    node_fs.writeSync(1, buffer, 0, 1); //node
    return c; //node
  }; //node

  getchar_sync = () => { //node
    let buffer = Buffer.alloc(1); //node
    if (node_fs.readSync(0, buffer, 0, 1)) //node
      return buffer[0]; //node
    return -1; //node
  }; //node

  getchar = () => { //node
    push(pos<input[lengthAttr] ? get_byte() : getchar_sync()); //node
    return true; // indicate that no further waiting is necessary //node
  }; //node

  sym2str = (s) => chars2str(s[1][0]); //node //debug
  chars2str = (s) => (s===NIL) ? "" : (String.fromCharCode(s[0])+chars2str(s[1])); //node //debug
  show_opnd = (o) => is_rib(o) ? "sym " + sym2str(o) : "int " + o; //node //debug
  show_stack = () => { //node //debug
    let s = stack; //node //debug
    let r = []; //node //debug
    while (!s[2]) { r[r[lengthAttr]]=s[0]; s=s[1]; } //node //debug
    console.log(require("util").inspect(r, {showHidden: false, depth: 2})); //node //debug
  } //node //debug

} else { // in web browser //node

  // Implement a simple console as a textarea in the web page

  domdoc = document;
  selstart = 0;
  addEventListenerAttr = "addEventListener";
  selectionStartAttr = "selectionStart";

  domdoc[addEventListenerAttr]("DOMContentLoaded", () => {
    run();
  });

  putchar = (c) => (selstart=txtarea[selectionStartAttr]=(txtarea.value += String.fromCharCode(c))[lengthAttr], c);

  getchar = () => pos<input[lengthAttr] && push(get_byte());
  show_stack = () => {console.log(stack)};
  sym2str = (s) => chars2str(s[1][0]); //node //debug
  chars2str = (s) => (s===NIL) ? "" : (String.fromCharCode(s[0])+chars2str(s[1])); //node //debug
  show_opnd = (o) => is_rib(o) ? "sym " + sym2str(o) : "int " + o; //node //debug
} //node

// VM

// build the symbol table

pos = 0;
get_byte = () => input[pos++].charCodeAt(0);
get_code = () => { let x = get_byte()-35; return x<0 ? 57 : x; };
get_int = (n) => { let x = get_code(); n *= 46; return x<46 ? n+x : get_int(n+x-46); };

pop = () => { let x = stack[0]; stack = stack[1]; return x; };

FALSE = [0,0,5]; TRUE = [0,0,5]; NIL = [0,0,5];

symtbl = NIL;
n = get_int(0);
while (n-- > 0) symtbl=[[0,[NIL,0,3],2],symtbl,0]; // symbols with empty names

accum = NIL;
n = 0;
while (1) {
  c = get_byte();
  if (c == 44) { symtbl=[[0,[accum,n,3],2],symtbl,0]; accum = NIL; n = 0; continue; }
  if (c == 59) break;
  accum = [c,accum,0];
  n++;
}

symtbl = [[0,[accum,n,3],2],symtbl,0];

symbol_ref = (n) => list_tail(symtbl,n)[0];
list_tail = (x,i) => i ? list_tail(x[1],i-1) : x;

// decode the instruction graph

stack = 0;

while (1) {
  x = get_code();
  n = x;
  d = 0;
  op = -1;
  while ((d=[20,30,0,10,11,4][++op])+2<n) n -= d+3;
  if (x>90)
    n = pop();
  else {
    if (!op) stack = [0,stack,0];
    n = n>=d ? (n==d ? get_int(0) : symbol_ref(get_int(n-d-1))) : op<3 ? symbol_ref(n) : n;
    if (4<op) {
      n = [[n,0,pop()],0,1];
      if (!stack) break;
      op=4;
    }
  }
  stack[0] = [op?op-1:0,n,stack[0]];
}

set_global = (x) => { symtbl[0][0] = x; symtbl = symtbl[1]; };

set_global([0,symtbl,1]); // primitive 0
set_global(FALSE);
set_global(TRUE);
set_global(NIL);

// RVM core

pc = n[0][2];
stack = [0,0,[5,0,0]]; // primordial continuation (executes halt instr.)

push = (x) => ((stack = [x,stack,0]), true);
bool_to_rib = (x) => x ? TRUE : FALSE;
// )@@
str_to_rib = (s) => {
    let l = s.length
    let i = l
    let a = NIL
    while (i) a=[s.charCodeAt(--i),a,0];
    return [a,l,3]
}
// )@@

find_sym = (name, symtbl) => {
  lst = rib_to_list(symtbl)
  return list_tail(symtbl, lst.indexOf(name))[0]

}
// )@@

function_to_rib = (f) => {
  let host_call = find_sym('host-call', symtbl)
  let id = find_sym('id', symtbl)
  let arg2 = find_sym('arg2', symtbl)
  let rib = [[0, 0, 1], [NIL, 0, 3], 2]
  if (host_call == -1 || id == -1){
    console.log("ERROR : you must define host-call as a primitive to convert a function to a rib")
    return 
  }

  let code = [3, foreign(f),  // push(foreign(f))
              [2, 1, // inverse arguments
               [0, host_call,  // call host_call primitive
                [0, arg2, // discard argument on stack
                 [0, id, 0]]]]] // return 
  let i = f.length // number of args
  while(i--){
    code = [3, 0,  // push 0
             [0, rib, // call rib
              code]]
  }
  code = [f.length, 0,     // number of params
          [3, NIL, code]] // push nil

  let env = 0 // no environment
  return [code, env, 1] // return the procedure
}
// )@@

any_to_rib = (v) => {
  return ({"number":(x)=>x,"boolean":bool_to_rib,"string":str_to_rib,"object":(x) => !Array.isArray(x) ? foreign(x) : list_to_rib(x), 'function':function_to_rib, 'undefined':()=>NIL}[typeof v](v))
}
// )@@

list_to_rib = (l,i=0) => (i<l.length?[any_to_rib(l[i]),list_to_rib(l,i+1),0]:NIL)
// )@@

rib_to_str = (r) => {
    let f = (c) => (c===NIL?"":String.fromCharCode(c[0])+f(c[1]))
    return f(r[0])
}
// )@@

rib_to_bool = (r) => {
  if (r === NIL){
    return []
  }
  if (r === FALSE){
    return false
  }
  if (r === TRUE){
    return true
  }
  console.error("Cannot convert ", r, " to bool");
}
// )@@

rib_to_list = (r) => {
  let elems = r[2] === 0 ? r : r[0];
  let lst = [];
  let f = (c) => {
    if (c !== NIL){
      lst.push(rib_to_any(c[0]))
      f(c[1])
    }
  }
  f(elems)
  return lst
}
// )@@

rib_to_function = (r) => {
  let func_stack = []
  let func = (...args) => {
    func_stack.push(pc)
    push(r)
    for(let a in args){
      push(any_to_rib(a))
    }
    pc = [0,args.length,[5, 0, 0]] // call function and then halt
    run()
    pc = func_stack.pop()
    return_value = pop()
    return rib_to_any(return_value)
  }
  return func
}
// )@@


rib_to_symbol = (r) => {
  return rib_to_str(r[1])
}
// )@@


rib_to_any = (r) => {
  if (r === undefined) return r;
  if (typeof r === "number") return r;
  let tag = r[2]
  return [rib_to_list, rib_to_function, rib_to_symbol, rib_to_str, rib_to_list, rib_to_bool, (x) => x[1]][tag](r);
}
 // )@@


foreign = (r) => [0, r, 6] // 6 is to tag a foreign object
// )@@

// f is a foreign object representing a function
host_call = () =>{
  args = pop();
  f = pop()[1];
  let r = f(...rib_to_list(args));
  return push(any_to_rib(r))
} 
// )@@

is_rib = (x) => x[lengthAttr];

get_opnd = (o) => is_rib(o) ? o : list_tail(stack,o);
get_cont = () => { let s = stack; while (!s[2]) s = s[1]; return s; };

prim1 = (f) => () => push(f(pop()));
prim2 = (f) => () => push(f(pop(),pop()));
prim3 = (f) => () => push(f(pop(),pop(),pop()));

primitives = [
  prim3((z, y, x) => [x, y, z]),                    //  @@(primitive (rib a b c))@@
  prim1((x) => x),                                  //  @@(primitive (id x))@@
  () => (pop(), true),                              //  @@(primitive (arg1 x y))@@
  () => { let y = pop(); pop(); return push(y); },  //  @@(primitive (arg2 x y))@@
  () => push([pop()[0],stack,1]),                   //  @@(primitive (close rib))@@
  prim1((x) => bool_to_rib(is_rib(x))),             //  @@(primitive (rib? rib) (use bool_to_rib))@@
  prim1((x) => x[0]),                               //  @@(primitive (field0 rib))@@
  prim1((x) => x[1]),                               //  @@(primitive (field1 rib))@@
  prim1((x) => x[2]),                               //  @@(primitive (field2 rib))@@
  prim2((y, x) => x[0]=y),                          //  @@(primitive (field0-set! rib))@@
  prim2((y, x) => x[1]=y),                          //  @@(primitive (field1-set! rib))@@
  prim2((y, x) => x[2]=y),                          //  @@(primitive (field2-set! rib))@@
  prim2((y, x) => bool_to_rib(x===y)),              //  @@(primitive (eqv? x y) (use bool_to_rib))@@
  prim2((y, x) => bool_to_rib(x<y)),                //  @@(primitive (< x y) (use bool_to_rib))@@
  prim2((y, x) => x+y),                             //  @@(primitive (+ x y))@@
  prim2((y, x) => x-y),                             //  @@(primitive (- x y))@@
  prim2((y, x) => x*y),                             //  @@(primitive (* x y))@@
  prim2((y, x) => x/y|0),                           //  @@(primitive (quotient x y))@@
  getchar,                                          //  @@(primitive (getchar))@@
  prim1(putchar),                                   //  @@(primitive (putchar c))@@
  () => pop() && halt(),//will crash with error on != 0 @@(primitive (exit n))@@
() => push(foreign(document)),() => push(console.log(rib_to_any(pop()))),prim1((e) => bool_to_rib(Array.isArray(e) && e[1] instanceof HTMLElement)),prim2((element, parent) => parent[1].append(rib_to_any(element))),() => push(foreign(document.createTextNode(rib_to_any(pop())))),() => push(foreign(document.createElement(rib_to_str(pop())))),prim3((value, name, e) => (e[1].addEventListener(rib_to_str(name), eval(rib_to_any(value))))),prim3((value, name, e) => any_to_rib((e[1].style[rib_to_str(name)] = rib_to_any(value)))),prim2((value, e) => any_to_rib((e[1].innerText = rib_to_any(value)))),prim3((value, name, e) => any_to_rib((e[1].setAttribute(rib_to_str(name), rib_to_any(value))))),prim2((attr, e) => any_to_rib(e[1][rib_to_str(attr)])),() => push(foreign(document.getElementById(rib_to_str(pop())))),() => push(foreign(document.querySelector(rib_to_str(pop())))),];

run = () => {
  while (1) {
    let o = pc[1];
    switch (pc[0]) {
    case 5: // halt
        return;
    case 0: // jump/call
        if (debug) { console.log((pc[2]===0 ? "--- jump " : "--- call ") + show_opnd(o)); show_stack(); } //debug
        o = get_opnd(o)[0];
        let c = o[0];
        if (is_rib(c)) {
            let c2 = [0,o,0];
            let s2 = c2;
            let nargs = c[0];
            while (nargs--) s2 = [pop(),s2,0];
            if (pc[2]===0) {
                // jump
                let k = get_cont();
                c2[0] = k[0];
                c2[2] = k[2];
            } else {
                // call
                c2[0] = stack;
                c2[2] = pc[2];
            }
            stack = s2;
        } else {
            if (!primitives[c]()) return;
            if (pc[2]===0) {
                // jump
                c = get_cont();
                stack[1] = c[0];
            } else {
                // call
                c = pc;
            }
        }
        pc = c;
        break;
    case 1: // set
        if (debug) { console.log("--- set " + show_opnd(o)); show_stack(); } //debug
        get_opnd(o)[0] = pop();
        break;
    case 2: // get
        if (debug) { console.log("--- get " + show_opnd(o)); show_stack(); } //debug
        push(get_opnd(o)[0]);
        break;
    case 3: // const
        if (debug) { console.log("--- const " + o); show_stack(); } //debug
        push(o);
        break;
    case 4: // if
        if (debug) { console.log("--- if"); show_stack(); } //debug
        if (pop() !== FALSE) { pc = pc[1]; continue; }
        break;
    }
      pc = pc[2];
  }
};

if (nodejs) run(); //node
